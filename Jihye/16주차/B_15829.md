# 🔥 17829 - Hashing
 
\[H = \sum_{i=0}^{l-1}{a_ir^i} \mod M\] 

보통 r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 우리가 직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.

이제 여러분이 할 일은 위 식을 통해 주어진 문자열의 해시 값을 계산하는 것이다. 그리고 이 함수는 간단해 보여도 자주 쓰이니까 기억해뒀다가 잘 써먹도록 하자.

문제에서 주어진 해시함수와 입력으로 주어진 문자열을 사용해 계산한 해시 값을 정수로 출력한다.

## ✏️ 코드
```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
let input = fs.readFileSync(filePath).toString().trim().split("\n");

let n = Number(input[0]);
let m = 1234567891;
let r = 1;
let result = 0;

for (let i = 0; i < n; i++) {
  result += (input[1].charCodeAt(i) - 96) * r;
  result = result % m;
  r *= 31;
  r %= m;
}

console.log(result);
```

## 🌱 설명
- 처음에는 `Math.pow(31, i)` 를 사용하여 제곱을 만들려고 했으나 50점이 나옴
- 너무 큰 값인 경우 오버플로우가 발생 (Number가 가질 수 있는 가장 큰 값은 1.8E308 이라고 한다)
- r을 직접 곱해주면서 너무 커지는 경우를 대비해 m 값인 `1234567891`을 나눠서 나머지를 사용하는 방식으로 해결